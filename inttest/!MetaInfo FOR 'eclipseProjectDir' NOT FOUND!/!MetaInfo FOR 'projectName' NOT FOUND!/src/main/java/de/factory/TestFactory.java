package de.factory;

import java.util.*;
import de.Test;
import de.builder.TestBuilder;
import de.factory.TestFactory;
import de.utils.*;

import org.apache.commons.lang.StringUtils;

/**
* Factory class of the MOGLiCC JavaBean Group.
* Creates Test instances with data for test purpose.
*
* @author generated by MOGLiCC
*/
public class TestFactory
{
	public static final int DEFAULT_MAX_LENGTH_STRING_VALUE = 1000;
	public static final int DEFAULT_MAX_LENGTH_NUMBER_VALUE = 8;
	public static final int DEFAULT_MIN_LENGTH_STRING_VALUE = 0;
	public static final int DEFAULT_MIN_LENGTH_NUMBER_VALUE = 1;
	public static final int NO_VALUE_AVAILABLE_IN_MODEL = -1;

	static final HashMap<String, List<String>> dataPool = new HashMap<String, List<String>>();
	static final HashMap<String, Integer> maxLengths = new HashMap<String, Integer>();
	static final HashMap<String, Integer> minLengths = new HashMap<String, Integer>();

	private static final String OBJECT_ID = "objectID";
	private static final Random randomizer = new Random(new Date().getTime());

	public static Integer getMaxLength(final String fieldname)
	{
		final Integer toReturn = maxLengths.get(fieldname);
		if (toReturn == null)
		{
			return NO_VALUE_AVAILABLE_IN_MODEL;
		}
		return maxLengths.get(fieldname);
	}

	public static Integer getMinLength(final String fieldname)
	{
		final Integer toReturn = minLengths.get(fieldname);
		if (toReturn == null)
		{
			return NO_VALUE_AVAILABLE_IN_MODEL;
		}
		return minLengths.get(fieldname);
	}

	/**
	 * @return the instance with all fields with maximum allowed number of chars
	 */
	public static Test createInstanceWithAllFieldsAtMaxLength()
	{
		final Test toReturn = new Test();


		return toReturn;
	}
	/**
	 * @return the instance with all fields with the minimum allowed number of chars
	 */
	public static Test createInstanceWithAllFieldsAtMinLength()
	{
		final Test toReturn = new Test();


		return toReturn;
	}

	/**
	 * deletes all data except in mandatory fields
	 */
	public static void removeAllDataFromOptionalFields(final Test instance)
	{
	}

	public static Test createInstanceOnlyWithMandatoryFields()
	{
		final Test toReturn = getByIndex(0);
		removeAllDataFromOptionalFields(toReturn);
		return toReturn;
	}

	public static List<Test> createAllFromDataPool()
	{
		final Object[] fields = dataPool.keySet().toArray();
		final int poolSize = dataPool.get(fields[0]).size();
		return createFirstFromDataPool( poolSize);
	}

	/**
	 * @param num number of Test objects to provide
	 * @return the first <num> objects in the pool
	 */
	public static List<Test> createFirstFromDataPool(final int num)
	{
		final int dataPoolNum = getNumberOfTestObjectsInDataPool();
		if (num > dataPoolNum)
		{
			throw new RuntimeException("Error: Cannot provide " + num + " Test objects. Pool contains only "
                                      + dataPoolNum + " objects.");
		}

		final List<Test> toReturn = new ArrayList<Test>();
		for (int i = 0; i < num; i++) {
			toReturn.add(buildObject(i));
		}

		return toReturn;
	}

	/**
	 * @param num index of Test object to provide
	 * @return the (<index>+1)th object in the pool
	 */
	public static Test getByIndex(final int index)
	{
		final int dataPoolNum = getNumberOfTestObjectsInDataPool();
		if (index > dataPoolNum)
		{
			throw new RuntimeException("Error: Cannot provide the " + index + "th Test object. Pool contains only "
                                     + dataPoolNum + " objects.");
		}
		return buildObject(index);
	}

	/**
	 * @param id of wanted Person object
	 * @return Person object identified by its object id
	 */
	public static Test getById(final String objectId)
	{
		final List<String> ids = dataPool.get( OBJECT_ID );
		int indexCounter = 0;
		for (final String id : ids) {
			if ( id.equals(objectId) )
			{
				return getByIndex(indexCounter);
			}
			indexCounter++;
		}
		return null;
	}

	/**
	 * @return a randomly chosen object from the pool
	 */
	public static Test createRandomFromDataPool()
	{
		final int limit = getNumberOfTestObjectsInDataPool();

		if (limit <= 0)
		{
			return null;  // no data available
		}

		final int index = randomizer.nextInt( limit );
		return buildObject(index);
	}

	/**
	 * Cuts the content of the named field by the numberCharToCut value if the content is not null.
	 */
	public static void cutFieldContent(final Test instance, final String fieldname, final int numberCharToCut)
	{
		System.err.println("Field <" + fieldname + "> is either unkown to the class 'Test' or cutting its field content is not supported.");
	}

	/**
	 * Appends the content of the named field by the textToAdd value if the content is not null.
    * This value must represent a number for numerical fields.
	 */
	public static void addToFieldContent(final Test instance, final String fieldname, final String textToAdd)
	{
		System.err.println("Field <" + fieldname + "> is either unkown to the class 'Test' or appending its field content is not supported.");
	}

   // *************************************************************************
   // ***************************  private methods  ***************************
   // *************************************************************************

	private static String getValue(final String field, final int index)
	{
		final List<String> list = dataPool.get(field);
		if (list == null)
		{
			throw new RuntimeException("Unkown field '" + field + "' in class 'Test'.");
		}

		if (index >= list.size())
		{
			return null;  // no value for this index available
		}

		return list.get(index);
	}

	private static Test buildObject(final int index)
	{
		TestBuilder builder = new TestBuilder();
		String value = null;
		return builder.build();
	}

	static int getNumberOfTestObjectsInDataPool()  {
		final String firstKey = TestFactory.dataPool.keySet().iterator().next();
		return TestFactory.dataPool.get(firstKey).size();
	}

	static
	{
		// fill data pool
		final List<String> objectIdList = new ArrayList<String>();
		dataPool.put(OBJECT_ID, objectIdList);

		// set maxLength values

		// set minLength values
	}


	/**
	 * Calls createInstanceWithAllFieldsAtMaxLength and addToFieldContent to fields of supported JavaType
	 * (these are: byte, Byte, int, Integer, double, Double, String, java.math.BigDecimal,
    * if MaxLength-metainfo is defined for the corresponding attribute in the data model.
	 * @return instance that causes validation exceptions for the supported fields.
	 */
	public static Test createInstanceWithAllSupportedFieldsExceedingMaxLength()
	{
		final Test toReturn = createInstanceWithAllFieldsAtMaxLength();

		// the meta model contains for class 'Test' no attribute with metainfo 'MaxLength'

		return toReturn;
	}

	/**
	 * Calls createInstanceWithAllFieldsAtMinLength and cutFieldContent to fields of supported JavaType
	 * (these are; byte, Byte, int, Integer, double, Double, String, java.math.BigDecimal),
	 * if MinLength-metainfo is defined for the corresponding attribute in the data model.
	 * @return instance that causes validation exceptions for the corresponding fields.
	 */
	public static Test createInstanceWithAllSupportedFieldsNotReachingMinLength()
	{
		final Test toReturn = createInstanceWithAllFieldsAtMinLength();

		// the meta model contains for class 'Test' no attribute with metainfo 'MinLength'

		return toReturn;
	}
}