@TargetFileName ${classDescriptor.simpleName}UnitTest.java # Name of output file with extension but without path
@TargetDir $model.getMetaInfoValueFor("eclipseProjectDir")/$model.getMetaInfoValueFor("projectName")/src/test/java/<package>
@CreateNew true # creates target dir if not existing and overwrites target file if existing
@NameOfValidModel MOGLiCC_JavaBeanModel

package ${classDescriptor.package};
'
import static org.junit.Assert.*;
'
import org.junit.*;
'
<<<<<<< HEAD:filemaker.classbased.velocity/src/main/resources/defaultInputData/MOGLiJavaBean_Test/A_MainTemplate.tpl
=======
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.DateTimeFormat;
'
>>>>>>> 656c84c58ad794ed34c58c30ecc9bf656c921412:filemaker.classbased.velocity/src/main/resources/defaultInputData/MOGLiJavaBean_Test/A_MainTemplate.tpl
import ${classDescriptor.package}.*;
import ${classDescriptor.package}.builder.*;
import ${classDescriptor.package}.validator.*;
import ${classDescriptor.package}.factory.*;
import ${classDescriptor.package}.utils.*;
'
#parse("commonSubtemplates/importDomainModelClasses.tpl")
'
/**
 * Tests basic JavaBean functionality for JavaBean '${classDescriptor.simpleName}.java'
 *
 * @author generated by MOGLiCC
 */
public class ${classDescriptor.simpleName}UnitTest {
<<<<<<< HEAD:filemaker.classbased.velocity/src/main/resources/defaultInputData/MOGLiJavaBean_Test/A_MainTemplate.tpl

=======
'
'	private final static DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern("$model.getMetaInfoValueFor("dateTimeFormat")");
'
>>>>>>> 656c84c58ad794ed34c58c30ecc9bf656c921412:filemaker.classbased.velocity/src/main/resources/defaultInputData/MOGLiJavaBean_Test/A_MainTemplate.tpl
#set( $className = $TemplateStringUtility.firstToLowerCase($classDescriptor.simpleName) )


'
'	private ${classDescriptor.simpleName} ${className}1;
'	private ${classDescriptor.simpleName} ${className}2;
'

	#parse("C_setupMethod.tpl")

'
'	@Test
'	public void returnsTrueWhenCallingEqualsMethodWithEqual${classDescriptor.simpleName}Instance() {
'		assertTrue("unequal instances", ${className}1.equals(${className}1));
'		assertTrue("unequal instances", ${className}1.equals(${className}2));
'	}
'
'	@Test
'	public void buildsEqualHashCodesForEqual${classDescriptor.simpleName}Instances() {
'		assertTrue("unequal instances", ${className}1.hashCode() == ${className}1.hashCode());
'		assertTrue("unequal instances", ${className}2.hashCode() == ${className}2.hashCode());
'	}
'
'

	#parse("D_testEqualsMethods.tpl")

'
	#parse("E_testHashcodeMethods.tpl")

'
	#parse("F_createsNewInstanceUsing_CloneWith_MethodOfBuilder.tpl")
	
'

#if ( $classDescriptor.doesHaveMetaInfo( "implements", "java.lang.Cloneable") )

'
'	@Test
'	public void clonesInstance() {
'		${classDescriptor.simpleName} clone = (${classDescriptor.simpleName})${className}1.clone();
'		assertTrue("unequal clone", ${className}1.equals(clone));
'	}
'

#end
}